// Simple MiniScript shim for browser
(function() {
    // Create global miniscript object
    window.miniscript = {
        version: "1.0.1",
        
        // Interpreter class
        Interpreter: function() {            this.variables = {
                // Add pi constant
                pi: Math.PI,
                  // Global range function
                range: function(x, y = null, step = null) {
                    // If only one argument, it's the end (with start=0, step=1)
                    if (y === null) {
                        y = x;
                        x = 0;
                        step = 1;
                    } else if (step === null) {
                        // With two arguments, step is determined by direction
                        step = x <= y ? 1 : -1;
                    }
                    
                    const result = [];
                    if (step > 0) {
                        // Ascending range
                        for (let i = x; i <= y; i += step) {
                            result.push(i);
                        }
                    } else {
                        // Descending range
                        for (let i = x; i >= y; i += step) {
                            result.push(i);
                        }
                    }
                    return this.enhanceListWithMethods(result);
                }
            };

            // Main code runner: parses and executes MiniScript code
            this.run = function(code) {
                const lines = code.split('\n');
                let i = 0;
                while (i < lines.length) {
                    let line = lines[i].trim();                    // --- SINGLE-LINE IF STATEMENT SUPPORT ---
                    if (line.startsWith("if ") && line.includes(" then") && !line.includes("end if")) {
                        const thenIndex = line.indexOf(" then");
                        const condExpr = line.substring(3, thenIndex).trim();
                        const rest = line.substring(thenIndex + 5).trim();
                        let condResult = this.evalCondition(condExpr);
                        if (condResult && rest.length > 0) {
                            this.run(rest);
                        }
                    }                    // --- FOR IN RANGE LOOP SUPPORT ---
                    else if (line.startsWith("for ") && line.includes(" in range(")) {
                        // Parse: for i in range(10, 1)
                        const forParts = line.match(/^for\s+(\w+)\s+in\s+range\(([^,]+),\s*([^)]+)\)/);
                        if (forParts) {
                            const varName = forParts[1];
                            const start = Number(this.evalExpr(forParts[2]));
                            const end = Number(this.evalExpr(forParts[3]));
                            let loopLines = [];
                            i++;
                            while (i < lines.length && !lines[i].trim().startsWith("end for")) {
                                loopLines.push(lines[i]);
                                i++;
                            }
                            for (let val = start; val >= end; val--) {
                                this.variables[varName] = val;
                                for (let loopLine of loopLines) {
                                    let trimmed = loopLine.trim();
                                    if (trimmed === "wait") {
                                        // Wait 200ms for demo (synchronous, not real async)
                                        const startTime = Date.now();
                                        while (Date.now() - startTime < 200) {}
                                    } else {
                                        this.run(trimmed);
                                    }
                                }
                            }
                        }
                    }                    // --- FOR IN LIST LOOP SUPPORT ---
                    else if (line.startsWith("for ") && line.includes(" in ") && !line.includes("range(")) {
                        // Parse: for item in myList
                        const forMatch = line.match(/^for\s+(\w+)\s+in\s+(.+)/);
                        if (forMatch) {
                            const itemVarName = forMatch[1];
                            const listExpr = forMatch[2];
                            const list = this.evalExpr(listExpr);
                            
                            if (Array.isArray(list)) {
                                let loopLines = [];
                                i++;
                                // Gather the loop body
                                while (i < lines.length && !lines[i].trim().startsWith("end for")) {
                                    loopLines.push(lines[i]);
                                    i++;
                                }
                                
                                // Execute the loop for each item in the list
                                for (let item of list) {
                                    this.variables[itemVarName] = item;
                                    for (let loopLine of loopLines) {
                                        let trimmed = loopLine.trim();
                                        if (trimmed === "wait") {
                                            // Wait 200ms for demo (synchronous, not real async)
                                            const startTime = Date.now();
                                            while (Date.now() - startTime < 200) {}
                                        } else {
                                            this.run(trimmed);
                                        }
                                    }
                                }
                            } else {
                                console.error(`Error: "${listExpr}" is not a list`);
                            }
                        }
                    }
                    // --- WHILE LOOP SUPPORT ---
                    else if (line.startsWith("while ")) {
                        const condExpr = line.substring(6).trim();
                        let loopLines = [];
                        i++;
                        // Collect all lines between while and end while
                        while (i < lines.length && !lines[i].trim().startsWith("end while")) {
                            loopLines.push(lines[i]);
                            i++;
                        }
                        
                        // Evaluate condition and execute loop body while condition is true
                        let condResult = this.evalCondition(condExpr);
                        while (condResult) {
                            // Execute the loop body
                            for (let loopLine of loopLines) {
                                let trimmed = loopLine.trim();
                                if (trimmed === "wait") {
                                    // Wait 200ms for demo (synchronous, not real async)
                                    const startTime = Date.now();
                                    while (Date.now() - startTime < 200) {}
                                } else {
                                    this.run(trimmed);
                                }
                            }
                            // Re-evaluate condition
                            condResult = this.evalCondition(condExpr);
                        }
                    }                    // --- MULTI-LINE IF/ELSE/ELSE IF SUPPORT ---
                    else if (line.startsWith("if ") && line.includes(" then")) {
                        const condExpr = line.substring(3, line.indexOf(" then")).trim();
                        let condResult = this.evalCondition(condExpr);
                        i++;
                        let blocks = [];
                        let currentBlock = [];
                        let conditions = [condResult];
                        let elseFound = false;
                        while (i < lines.length && !lines[i].trim().startsWith("end if")) {
                            let innerLine = lines[i].trim();
                            if (innerLine.startsWith("else if ") && innerLine.includes(" then")) {
                                blocks.push(currentBlock);
                                currentBlock = [];                                // Parse new else if condition
                                const elseIfCond = innerLine.substring(8, innerLine.indexOf(" then")).trim();
                                let elseIfResult = this.evalCondition(elseIfCond);
                                conditions.push(elseIfResult);
                            } else if (innerLine === "else") {
                                blocks.push(currentBlock);
                                currentBlock = [];
                                elseFound = true;
                            } else {
                                currentBlock.push(innerLine);
                            }
                            i++;
                        }
                        blocks.push(currentBlock);
                        // Find first true condition
                        let blockToRun = null;
                        for (let j = 0; j < conditions.length; j++) {
                            if (conditions[j]) {
                                blockToRun = blocks[j];
                                break;
                            }
                        }
                        if (!blockToRun && elseFound) {
                            blockToRun = blocks[blocks.length - 1];
                        }
                        if (blockToRun) {
                            for (let innerLine of blockToRun) {
                                this.run(innerLine);
                            }
                        }
                    }                    // --- PRINT STATEMENT SUPPORT ---
                    else if (line.startsWith("print ")) {
                        const expr = line.substring(6).trim();
                        let val = this.evalExpr(expr);
                        // Convert arrays and objects to string for display
                        if (Array.isArray(val)) {
                            console.log(JSON.stringify(val));
                        } else if (typeof val === 'object' && val !== null) {
                            console.log(JSON.stringify(val));
                        } else {
                            console.log(val);
                        }                    }// --- PUSH METHOD CALLS (both list and map) ---
                    else if (line.includes(".push(") && line.endsWith(")")) {
                        // Handle both list.push(item) and map.push(key) methods
                        const dotIdx = line.indexOf('.');
                        const objName = line.substring(0, dotIdx).trim();
                        const argStart = line.indexOf('(');
                        const argEnd = line.lastIndexOf(')');
                        const argExpr = line.substring(argStart + 1, argEnd).trim();
                        
                        // Get the object and the argument
                        const obj = this.variables[objName];
                        const arg = this.evalExpr(argExpr);
                        
                        // Check if it's a list (array)
                        if (Array.isArray(obj)) {
                            obj.push(arg);
                        } 
                        // Check if it's a map (object but not array)
                        else if (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {
                            obj.push(arg);
                        } 
                        else {
                            console.error(`Error: ${objName} is not a list or map`);
                        }
                    }
                    else if (line.includes(".pop()")) {
                        // Check if we're assigning the result
                        if (line.includes("=")) {
                            const parts = line.split("=").map(p => p.trim());
                            const varName = parts[0];
                            const popExpr = parts[1]; // something like "myList.pop()"
                            
                            // Extract list name from the pop expression
                            const dotIdx = popExpr.indexOf('.');
                            const listName = popExpr.substring(0, dotIdx).trim();
                            const list = this.variables[listName];
                            
                            // Check if it's a list, and if so, pop the last item
                            if (Array.isArray(list)) {
                                const poppedItem = list.pop();
                                this.variables[varName] = poppedItem;
                            } else {
                                console.error(`Error: ${listName} is not a list`);
                                this.variables[varName] = null;
                            }
                        } else {
                            // Just popping without assignment
                            const dotIdx = line.indexOf('.');
                            const listName = line.substring(0, dotIdx).trim();
                            const list = this.variables[listName];
                            
                            // Check if it's a list, and if so, pop the last item
                            if (Array.isArray(list)) {
                                list.pop();
                            } else {
                                console.error(`Error: ${listName} is not a list`);
                            }                        }
                    }
                    else if (line.includes(".size")) {
                        // Handle map.size property
                        if (line.includes("=")) {
                            const parts = line.split("=").map(p => p.trim());
                            const varName = parts[0];
                            const expr = parts[1];
                            const dotIdx = expr.indexOf('.');
                            const mapName = expr.substring(0, dotIdx).trim();
                            const mapObj = this.variables[mapName];
                            
                            if (typeof mapObj === 'object' && mapObj !== null && !Array.isArray(mapObj)) {
                                this.variables[varName] = Object.keys(mapObj).length;
                            } else {
                                console.error(`Error: ${mapName} is not a map`);
                                this.variables[varName] = 0;
                            }
                        }
                    }                    // --- MAP METHOD CALLS ---
                    else if (line.includes(".hasIndex(") && line.endsWith(")")) {
                        // Handle map.hasIndex(key) method call in assignment
                        if (line.includes("=")) {
                            const parts = line.split("=").map(p => p.trim());
                            const varName = parts[0];
                            const expr = parts[1]; // something like "myMap.hasIndex('key')"
                            
                            const dotIdx = expr.indexOf('.');
                            const mapName = expr.substring(0, dotIdx).trim();
                            const argStart = expr.indexOf('(');
                            const argEnd = expr.lastIndexOf(')');
                            const keyExpr = expr.substring(argStart + 1, argEnd).trim();
                            
                            const mapObj = this.variables[mapName];
                            const key = this.evalExpr(keyExpr);
                            
                            if (typeof mapObj === 'object' && mapObj !== null && !Array.isArray(mapObj)) {
                                this.variables[varName] = mapObj.hasIndex(key);
                            } else {
                                console.error(`Error: ${mapName} is not a map`);
                                this.variables[varName] = 0;
                            }
                        }
                    }
                    else if (line.includes(".indexOf(") && line.endsWith(")")) {
                        // Handle map.indexOf(value, after=null) method call
                        if (line.includes("=")) {
                            const parts = line.split("=").map(p => p.trim());
                            const varName = parts[0];
                            const expr = parts[1];
                            
                            const dotIdx = expr.indexOf('.');
                            const mapName = expr.substring(0, dotIdx).trim();
                            const argStart = expr.indexOf('(');
                            const argEnd = expr.lastIndexOf(')');
                            const argsStr = expr.substring(argStart + 1, argEnd).trim();
                            
                            // Parse arguments (value, and optional after)
                            const args = argsStr.split(',').map(arg => arg.trim());
                            const value = this.evalExpr(args[0]);
                            const after = args.length > 1 ? this.evalExpr(args[1]) : null;
                            
                            const mapObj = this.variables[mapName];
                            
                            if (typeof mapObj === 'object' && mapObj !== null && !Array.isArray(mapObj)) {
                                this.variables[varName] = mapObj.indexOf(value, after);
                            } else {
                                console.error(`Error: ${mapName} is not a map`);
                                this.variables[varName] = null;
                            }
                        }                    }else if (line.includes(".remove(") && line.endsWith(")")) {
                        // Handle map.remove(key) method call
                        const dotIdx = line.indexOf('.');
                        const mapName = line.substring(0, dotIdx).trim();
                        const argStart = line.indexOf('(');
                        const argEnd = line.lastIndexOf(')');
                        const keyExpr = line.substring(argStart + 1, argEnd).trim();
                        
                        const mapObj = this.variables[mapName];
                        const key = this.evalExpr(keyExpr);
                        
                        if (typeof mapObj === 'object' && mapObj !== null && !Array.isArray(mapObj)) {
                            mapObj.remove(key);
                        } else {
                            console.error(`Error: ${mapName} is not a map`);
                        }
                    }// --- VARIABLE ASSIGNMENT SUPPORT ---
                    else if (line.includes("=")) {
                        const [leftSide, valueRaw] = line.split("=").map(s => s.trim());
                        // Always evaluate the right-hand side as an expression
                        let value = this.evalExpr(valueRaw);
                        
                        // Check if this is a map property assignment via dot notation (map.key = value)
                        if (leftSide.includes(".") && !leftSide.includes("[")) {
                            const parts = leftSide.split(".");
                            const mapName = parts[0];
                            const propName = parts[1];
                            
                            if (this.variables.hasOwnProperty(mapName)) {
                                const mapObj = this.variables[mapName];
                                if (typeof mapObj === 'object' && mapObj !== null && !Array.isArray(mapObj)) {
                                    mapObj[propName] = value;
                                } else {
                                    console.error(`Error: ${mapName} is not a map`);
                                }
                            }
                        } 
                        // Check if this is a map indexing assignment (map["key"] = value or map[0] = value)
                        else if (leftSide.includes("[") && leftSide.includes("]")) {
                            const bracketIdx = leftSide.indexOf('[');
                            const containerName = leftSide.substring(0, bracketIdx).trim();
                            const keyExpr = leftSide.substring(bracketIdx + 1, leftSide.lastIndexOf(']')).trim();
                            
                            if (this.variables.hasOwnProperty(containerName)) {
                                const container = this.variables[containerName];
                                const key = this.evalExpr(keyExpr);
                                
                                if (typeof container === 'object' && container !== null) {
                                    // For both arrays and maps
                                    container[key] = value;
                                } else {
                                    console.error(`Error: ${containerName} is not a container (array or map)`);
                                }
                            }
                        }
                        // Regular variable assignment
                        else {
                            this.variables[leftSide] = value;
                        }
                    }
                    // --- IGNORE EMPTY LINES ---
                    i++;
                }
                return true;
            };            // Evaluate an expression (supports input(), val(), math, and variables)
            this.evalExpr = function(expr) {
                expr = expr.trim();
                // input()
                if (expr.startsWith("input(")) {
                    let promptText = expr.substring(6, expr.length-1);
                    if (promptText.startsWith('"') && promptText.endsWith('"')) {
                        promptText = promptText.substring(1, promptText.length-1);
                    }
                    return window.prompt(promptText);
                }
                // val()
                if (expr.startsWith("val(")) {
                    let inner = expr.substring(4, expr.length-1);
                    return Number(this.evalExpr(inner));
                }
                // sqrt() function
                if (expr.startsWith("sqrt(")) {
                    const inner = expr.substring(5, expr.length - 1);
                    const value = Number(this.evalExpr(inner));
                    return Math.sqrt(value);
                }                // round() function
                if (expr.startsWith("round(")) {
                    const inner = expr.substring(6, expr.length - 1);
                    const value = Number(this.evalExpr(inner));
                    return Math.round(value);
                }
                  // range() function
                if (expr.startsWith("range(")) {
                    const argsStr = expr.substring(6, expr.length - 1);
                    const args = argsStr.split(',').map(arg => this.evalExpr(arg.trim()));
                    
                    if (args.length === 1) {
                        return this.variables.range.call(this, args[0]);
                    } else if (args.length === 2) {
                        return this.variables.range.call(this, args[0], args[1]);
                    } else if (args.length === 3) {
                        return this.variables.range.call(this, args[0], args[1], args[2]);
                    } else {
                        console.error("range() requires 1-3 arguments");
                        return [];
                    }
                }
                // Variable
                if (this.variables.hasOwnProperty(expr)) {
                    return this.variables[expr];
                }                // null literal
                if (expr === "null") {
                    return null;
                }
                // Map literal - {"key": value, "key2": value2}
                if (expr.startsWith('{') && expr.endsWith('}')) {
                    const mapContent = expr.substring(1, expr.length-1).trim();
                    if (mapContent === "") {
                        const emptyMap = {}; // Empty map
                        this.enhanceMapWithMethods(emptyMap);
                        return emptyMap;
                    }
                    
                    // Parse map key-value pairs, respecting string literals and nested structures
                    let pairs = [];
                    let currentPair = "";
                    let inString = false;
                    let bracketDepth = 0;
                    let braceDepth = 0;
                    
                    for (let i = 0; i < mapContent.length; i++) {
                        const char = mapContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentPair += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentPair += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentPair += char;
                        } else if (char === '{') {
                            braceDepth++;
                            currentPair += char;
                        } else if (char === '}') {
                            braceDepth--;
                            currentPair += char;
                        } else if (char === ',' && !inString && bracketDepth === 0 && braceDepth === 0) {
                            // Pair separator found
                            pairs.push(currentPair.trim());
                            currentPair = "";
                        } else {
                            currentPair += char;
                        }
                    }
                    
                    // Add the last pair
                    if (currentPair.trim()) {
                        pairs.push(currentPair.trim());
                    }
                    
                    // Evaluate each key-value pair in the map
                    const map = {};
                    for (const pair of pairs) {
                        const colonIdx = pair.indexOf(':');
                        if (colonIdx !== -1) {
                            const keyExpr = pair.substring(0, colonIdx).trim();
                            const valueExpr = pair.substring(colonIdx + 1).trim();
                            
                            // Evaluate key (usually a string)
                            let key = this.evalExpr(keyExpr);
                            if (typeof key !== 'string') {
                                // Convert non-string keys to strings
                                key = String(key);
                            }
                            
                            // Evaluate value
                            const value = this.evalExpr(valueExpr);
                            
                            // Set the key-value pair
                            map[key] = value;
                        }
                    }
                    
                    // Add map methods
                    this.enhanceMapWithMethods(map);
                    
                    return map;
                }                // In MiniScript, maps have built-in methods that should be available via dot notation
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
                
                // List literal - [1, 2, 3]
                if (expr.startsWith('[') && expr.endsWith(']')) {
                    const listContent = expr.substring(1, expr.length-1).trim();
                    if (listContent === "") {
                        return this.enhanceListWithMethods([]); // Empty list with methods
                    }
                    
                    // Parse list items, respecting string literals and nested structures
                    let items = [];
                    let currentItem = "";
                    let inString = false;
                    let bracketDepth = 0;
                    
                    for (let i = 0; i < listContent.length; i++) {
                        const char = listContent[i];
                        
                        if (char === '"') {
                            inString = !inString;
                            currentItem += char;
                        } else if (char === '[') {
                            bracketDepth++;
                            currentItem += char;
                        } else if (char === ']') {
                            bracketDepth--;
                            currentItem += char;
                        } else if (char === ',' && !inString && bracketDepth === 0) {
                            // Item separator found
                            items.push(currentItem.trim());
                            currentItem = "";
                        } else {
                            currentItem += char;
                        }
                    }
                    
                    // Add the last item
                    if (currentItem.trim()) {
                        items.push(currentItem.trim());
                    }
                    
                    // Evaluate each item in the list and enhance with MiniScript list methods
                    return this.enhanceListWithMethods(items.map(item => this.evalExpr(item)));
                }

                // Enhance JavaScript arrays with MiniScript list methods
                this.enhanceListWithMethods = function(list) {
                    if (!Array.isArray(list)) return list;
                    
                    // .hasIndex(i) - 1 if i is in the range [0, self.len); otherwise 0
                    list.hasIndex = function(i) {
                        const index = Number(i);
                        return !isNaN(index) && index >= 0 && index < list.length ? 1 : 0;
                    };
                    
                    // .indexes - range(0, self.len-1)
                    Object.defineProperty(list, 'indexes', {
                        get: function() {
                            return Array.from({ length: list.length }, (_, i) => i);
                        }
                    });
                    
                    // .indexOf(x, after=null) - similar to JS indexOf but with 'after' parameter
                    const originalIndexOf = list.indexOf;
                    list.indexOf = function(value, after = null) {
                        if (after === null) {
                            return originalIndexOf.call(list, value);
                        }
                        
                        for (let i = after + 1; i < list.length; i++) {
                            if (list[i] === value) {
                                return i;
                            }
                        }
                        return -1;
                    };
                    
                    // .join(delimiter=" ") - joins elements into a string
                    const originalJoin = list.join;
                    list.join = function(delimiter = " ") {
                        return originalJoin.call(list, delimiter);
                    };
                    
                    // .len - length property
                    Object.defineProperty(list, 'len', {
                        get: function() {
                            return list.length;
                        }
                    });
                    
                    // .pop - removes and returns the last element (already exists in JS arrays)
                    
                    // .pull - removes and returns the first element
                    list.pull = function() {
                        return list.shift();
                    };
                    
                    // .push(x) - append element (already exists in JS arrays)
                    
                    // .shuffle - randomly rearranges the elements
                    Object.defineProperty(list, 'shuffle', {
                        get: function() {
                            // Fisher-Yates shuffle algorithm
                            for (let i = list.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [list[i], list[j]] = [list[j], list[i]];
                            }
                            return list; // Allow chaining
                        }
                    });
                    
                    // .sort(key=null) - sorts list, optionally by key for list of maps
                    const originalSort = list.sort;
                    list.sort = function(key = null) {
                        if (key === null) {
                            // Default sorting (strings alphabetically, numbers numerically)
                            return originalSort.call(list, (a, b) => {
                                if (typeof a === 'number' && typeof b === 'number') {
                                    return a - b;
                                }
                                return String(a).localeCompare(String(b));
                            });
                        } else {
                            // Sort by key (for list of maps)
                            return originalSort.call(list, (a, b) => {
                                const aVal = typeof a === 'object' && a !== null ? a[key] : null;
                                const bVal = typeof b === 'object' && b !== null ? b[key] : null;
                                
                                if (typeof aVal === 'number' && typeof bVal === 'number') {
                                    return aVal - bVal;
                                }
                                return String(aVal).localeCompare(String(bVal));
                            });
                        }
                    };
                    
                    // .sum - total of all numeric elements
                    Object.defineProperty(list, 'sum', {
                        get: function() {
                            return list.reduce((total, val) => {
                                return total + (typeof val === 'number' ? val : 0);
                            }, 0);
                        }
                    });
                    
                    // .remove(i) - removes element at index i
                    list.remove = function(i) {
                        const index = Number(i);
                        if (!isNaN(index) && index >= 0 && index < list.length) {
                            list.splice(index, 1);
                            return 1; // Return 1 if successful
                        }
                        return 0; // Return 0 if index not valid
                    };
                    
                    // .replace(oldVal, newVal, maxCount=null) - replaces values
                    list.replace = function(oldVal, newVal, maxCount = null) {
                        let replacements = 0;
                        for (let i = 0; i < list.length; i++) {
                            if (list[i] === oldVal) {
                                list[i] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements; // Return number of replacements made
                    };
                    
                    // .slice() - create a copy of all or part of the list (not in MiniScript spec but useful for tests)
                    const originalSlice = list.slice;
                    list.slice = function(start = 0, end = list.length) {
                        const result = originalSlice.call(list, start, end);
                        return this.enhanceListWithMethods(result);
                    }.bind(this);
                    
                    return list;
                };
                
                // Enhance objects with MiniScript map methods
                this.enhanceMapWithMethods = function(map) {
                    // Helper to filter out method names from object keys
                    const getDataKeys = () => {
                        const methodNames = ['hasIndex', 'indexOf', 'remove', 'replace', 'push', 'pop', 'shuffle', 'sum'];
                        return Object.keys(map).filter(key => !methodNames.includes(key));
                    };
                    
                    // hasIndex(x) - 1 if x is a key contained in self; 0 otherwise
                    map.hasIndex = function(key) {
                        return getDataKeys().includes(String(key)) ? 1 : 0;
                    };
                    
                    // indexes - list containing all keys of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'indexes', {
                        get: function() {
                            return getDataKeys();
                        }
                    });
                    
                    // indexOf(x, after=null) - first key in self that maps to x, or null if none
                    map.indexOf = function(value, after = null) {
                        const keys = getDataKeys();
                        let startIndex = 0;
                        
                        // If 'after' is specified, find where to start searching
                        if (after !== null) {
                            const afterIndex = keys.indexOf(String(after));
                            if (afterIndex !== -1) {
                                startIndex = afterIndex + 1;
                            }
                        }
                        
                        // Search for the value starting from startIndex
                        for (let i = startIndex; i < keys.length; i++) {
                            if (map[keys[i]] === value) {
                                return keys[i];
                            }
                        }
                        return null;
                    };
                    
                    // len - length (number of key-value pairs) of self (property, not a method)
                    Object.defineProperty(map, 'len', {
                        get: function() {
                            return getDataKeys().length;
                        }
                    });
                    
                    // pop - remove and return an arbitrary key from self
                    Object.defineProperty(map, 'pop', {
                        get: function() {
                            const keys = getDataKeys();
                            if (keys.length === 0) return null;
                            const key = keys[0]; // arbitrary key (first one)
                            const value = map[key];
                            delete map[key];
                            return key; // MiniScript pop returns the key, not the value
                        }
                    });
                    
                    // push(x) - equivalent to self[x] = 1
                    map.push = function(key) {
                        map[String(key)] = 1;
                    };
                    
                    // remove(x) - removes the key-value pair where key=x from self (in place)
                    map.remove = function(key) {
                        const keyStr = String(key);
                        if (getDataKeys().includes(keyStr)) {
                            delete map[keyStr];
                            return 1; // MiniScript returns 1 if key was found and removed
                        }
                        return 0; // Returns 0 if key was not found
                    };
                    
                    // replace(oldVal, newVal, maxCount=null) - replaces values matching oldVal with newVal
                    map.replace = function(oldVal, newVal, maxCount = null) {
                        const keys = getDataKeys();
                        let replacements = 0;
                        
                        for (let key of keys) {
                            if (map[key] === oldVal) {
                                map[key] = newVal;
                                replacements++;
                                if (maxCount !== null && replacements >= maxCount) {
                                    break;
                                }
                            }
                        }
                        return replacements;
                    };
                    
                    // shuffle - randomly remaps values for keys
                    Object.defineProperty(map, 'shuffle', {
                        get: function() {
                            const keys = getDataKeys();
                            const values = keys.map(key => map[key]);
                            
                            // Fisher-Yates shuffle algorithm
                            for (let i = values.length - 1; i > 0; i--) {
                                const j = Math.floor(Math.random() * (i + 1));
                                [values[i], values[j]] = [values[j], values[i]];
                            }
                            
                            // Reassign shuffled values to keys
                            keys.forEach((key, index) => {
                                map[key] = values[index];
                            });
                            
                            return map; // Return self for chaining
                        }
                    });
                    
                    // sum - total of all numeric values in self
                    Object.defineProperty(map, 'sum', {
                        get: function() {
                            const keys = getDataKeys();
                            let total = 0;
                            for (let key of keys) {
                                const value = map[key];
                                if (typeof value === 'number' && !isNaN(value)) {
                                    total += value;
                                }
                            }
                            return total;
                        }
                    });
                    
                    // values - list containing all values of self, in arbitrary order (property, not a method)
                    Object.defineProperty(map, 'values', {
                        get: function() {
                            return getDataKeys().map(key => map[key]);
                        }
                    });
                    
                    return map;
                };
            },
            
            // Global function: runs MiniScript code in the global scope
            run: function(code) {
                // Create a new Interpreter instance for running the code
                const interpreter = new this.Interpreter();
                
                // Run the code
                return interpreter.run(code);
            }
        };
    })();